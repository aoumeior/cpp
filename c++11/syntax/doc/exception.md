# 异常

异常机制是`c++`比较难把握的一个点，我将花费一些时间去整理一些`c++`使用者对异常的使用和看法。

**如下**


陈硕在知乎谈过这个问题，解释了异常的来源，和异常在解决问题时所面对的新问题：

A. C++ 引入异常的原因之一是为了能让构造函数报错

    1. 数组元素构造时抛异常，前面已经构造好的元素要析构，还没有构造的元素不能析构。 
    2. 构造函数的初始化列表里抛异常，前面已经构造好的成员和基类子对象要析构，还没有构造的成员则不能析构。而且这个异常捕获之后必须重新抛出（编译器强制），因为C++不允许“半吊子”构造的对象存在。
    3. 多继承中某个基类的构造函数抛异常，那么已经构造好的基类子对象要析构，还没有构造的基类子对象则不能析构。虚拟继承，虚基类只能析构一次，你慢慢想吧。 
    4. 函数实参对象构造时抛异常，那么多个实参中已经构造好的实参对象要析构，尚未构造的实参对象不能析构。
    5. std::vector 在 resizing 的时候某个元素的拷贝发生异常，那么前面已经拷贝的元素要析构，尚未拷贝的元素则不必也不能析构，去看 gcc vector::_M_insert_aux 的代码有多麻烦。

B. C++ 引入异常的另一个原因是让 `dynamic_cast<Derived&>(baseReference)` 能报错，因为没有 null reference。

C. 还有一个原因是 overloaded operator 能报错，毕竟 operator 的返回类型往往无法包含 error code，例如 `operator = `。


vczh:

1. 异常，是用来报告你能恢复的那一类错误的。


朱元：

抛异常的代码一定要本着：“我被骗了（该assert的事情没有保证到，例如enable_share_from_this却没有用shared_ptr去管理），我对整块代码上下文流程都不信任了，我要杀你（这个进程）！“的态度去抛异常。

catch 异常的代码一定要本着：”我完全理解你的愤怒，我信任你应该没有什么事情干到一半却没回滚，并且我能够处理或恢复你尝试杀人带来的一系列析构所造成的副作用，你该干的活没干我也可以不care，进程也完全能够接受因为处理catch而带来的时间开销。所以我不让你杀进程。“这样的态度去接异常。

可以看出来，catch异常的（对代码流程和抛异常的原因的了解）要求比抛异常要高很多，所以不推荐随便的去catch异常，除非是你觉得有问题的第三方库却不得不用的。
----------------------------------------------------------------------------------------------------------------------
个人觉得，如果c++只有throw 而没有try catch 也是挺好的。(如果在析构函数里产生异常，编译器不允许他离开析构函数体，在析构函数体里终止进程而不是回到main函数在终止。)